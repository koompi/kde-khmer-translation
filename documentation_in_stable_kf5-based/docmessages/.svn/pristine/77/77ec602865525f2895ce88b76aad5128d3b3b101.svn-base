# translation of kate_regular-expressions.po to British English
# Copyright (C) 2003 Free Software Foundation, Inc.
# Malcolm Hunter <malcolm.hunter@gmx.co.uk>, 2003
#
msgid ""
msgstr ""
"Project-Id-Version: kate_regular-expressions\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2020-10-02 00:47+0000\n"
"PO-Revision-Date: 2003-11-13 01:03+0000\n"
"Last-Translator: Malcolm Hunter <malcolm.hunter@gmx.co.uk>\n"
"Language-Team: British English <kde-l10n-en_gb@kde.org>\n"
"Language: en_GB\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.0.1\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#. Tag: author
#: regular-expressions.docbook:4
#, no-c-format
msgid "&Anders.Lund; &Anders.Lund.mail;"
msgstr "&Anders.Lund; &Anders.Lund.mail;"

#. Tag: trans_comment
#: regular-expressions.docbook:5
#, no-c-format
msgid "ROLES_OF_TRANSLATORS"
msgstr ""
"<othercredit role=\"translator\"><firstname>Malcolm</"
"firstname><surname>Hunter</surname><affiliation><address><email>malcolm."
"hunter@gmx.co.uk</email></address></affiliation><contrib>Conversion to "
"British English</contrib></othercredit>"

#. Tag: title
#: regular-expressions.docbook:9
#, no-c-format
msgid "Regular Expressions"
msgstr "Regular Expressions"

#. Tag: synopsis
#: regular-expressions.docbook:11
#, fuzzy, no-c-format
#| msgid ""
#| "This Appendix contains a brief but hopefully sufficient and\n"
#| "covering introduction to the world of <emphasis>regular\n"
#| "expressions</emphasis>. It documents regular expressions in the form\n"
#| "available within &kate;, which is not compatible with the regular\n"
#| "expressions of perl, nor with those of for example\n"
#| "<command>grep</command>."
msgid ""
"This Appendix contains a brief but hopefully sufficient and\n"
"covering introduction to the world of <emphasis>regular\n"
"expressions</emphasis>. It documents regular expressions in the form\n"
"available within &kappname;, which is not compatible with the regular\n"
"expressions of perl, nor with those of for example\n"
"<command>grep</command>."
msgstr ""
"This Appendix contains a brief but hopefully sufficient and\n"
"covering introduction to the world of <emphasis>regular\n"
"expressions</emphasis>. It documents regular expressions in the form\n"
"available within &kate;, which is not compatible with the regular\n"
"expressions of perl, nor with those of for example\n"
"<command>grep</command>."

#. Tag: title
#: regular-expressions.docbook:15
#, no-c-format
msgid "Introduction"
msgstr "Introduction"

#. Tag: para
#: regular-expressions.docbook:17
#, no-c-format
msgid ""
"<emphasis>Regular Expressions</emphasis> provides us with a way to describe "
"some possible contents of a text string in a way understood by a small piece "
"of software, so that it can investigate if a text matches, and also in the "
"case of advanced applications with the means of saving pieces or the "
"matching text."
msgstr ""
"<emphasis>Regular Expressions</emphasis> provides us with a way to describe "
"some possible contents of a text string in a way understood by a small piece "
"of software, so that it can investigate if a text matches, and also in the "
"case of advanced applications with the means of saving pieces or the "
"matching text."

#. Tag: para
#: regular-expressions.docbook:23
#, no-c-format
msgid ""
"An example: Say you want to search a text for paragraphs that starts with "
"either of the names <quote>Henrik</quote> or <quote>Pernille</quote> "
"followed by some form of the verb <quote>say</quote>."
msgstr ""
"An example: Say you want to search a text for paragraphs that starts with "
"either of the names <quote>Henrik</quote> or <quote>Pernille</quote> "
"followed by some form of the verb <quote>say</quote>."

#. Tag: para
#: regular-expressions.docbook:28
#, fuzzy, no-c-format
msgid ""
"With a normal search, you would start out searching for the first name, "
"<quote>Henrik</quote> maybe followed by <quote>sa</quote> like this: "
"<userinput>Henrik sa</userinput>, and while looking for matches, you would "
"have to discard those not being the beginning of a paragraph, as well as "
"those in which the word starting with the letters <quote>sa</quote> was not "
"either <quote>says</quote>, <quote>said</quote> or so. And then of course "
"repeat all of that with the next name..."
msgstr ""
"With a normal search, you would start out searching for the first name, "
"<quote>Henrik</quote> maybe followed by <quote>sa</quote> like this: "
"<userinput>Henrik sa</userinput>, and while looking for matches, you would "
"have to discard those not being the beginning of a paragraph, as well as "
"those in which the word starting with the letters <quote>sa</quote> was not "
"either <quote>says</quote>, <quote>said</quote> or so. And then of cause "
"repeat all of that with the next name..."

#. Tag: para
#: regular-expressions.docbook:37
#, no-c-format
msgid ""
"With Regular Expressions, that task could be accomplished with a single "
"search, and with a larger degree of preciseness."
msgstr ""
"With Regular Expressions, that task could be accomplished with a single "
"search, and with a larger degree of preciseness."

#. Tag: para
#: regular-expressions.docbook:40
#, no-c-format
msgid ""
"To achieve this, Regular Expressions defines rules for expressing in details "
"a generalization of a string to match. Our example, which we might literally "
"express like this: <quote>A line starting with either <quote>Henrik</quote> "
"or <quote>Pernille</quote> (possibly following up to 4 blanks or tab "
"characters) followed by a whitespace followed by <quote>sa</quote> and then "
"either <quote>ys</quote> or <quote>id</quote></quote> could be expressed "
"with the following regular expression:"
msgstr ""
"To achieve this, Regular Expressions defines rules for expressing in details "
"a generalisation of a string to match. Our example, which we might literally "
"express like this: <quote>A line starting with either <quote>Henrik</quote> "
"or <quote>Pernille</quote> (possibly following up to 4 blanks or tab "
"characters) followed by a whitespace followed by <quote>sa</quote> and then "
"either <quote>ys</quote> or <quote>id</quote></quote> could be expressed "
"with the following regular expression:"

#. Tag: userinput
#: regular-expressions.docbook:47
#, no-c-format
msgid "^[ \\t]{0,4}(Henrik|Pernille) sa(ys|id)"
msgstr "^[ \\t]{0,4}(Henrik|Pernille) sa(ys|id)"

#. Tag: para
#: regular-expressions.docbook:50
#, no-c-format
msgid ""
"The above example demonstrates all four major concepts of modern Regular "
"Expressions, namely:"
msgstr ""
"The above example demonstrates all four major concepts of modern Regular "
"Expressions, namely:"

#. Tag: para
#: regular-expressions.docbook:54
#, no-c-format
msgid "<para>Patterns</para>"
msgstr "<para>Patterns</para>"

#. Tag: para
#: regular-expressions.docbook:55
#, no-c-format
msgid "<para>Assertions</para>"
msgstr "<para>Assertions</para>"

#. Tag: para
#: regular-expressions.docbook:56
#, no-c-format
msgid "<para>Quantifiers</para>"
msgstr "<para>Quantifiers</para>"

#. Tag: para
#: regular-expressions.docbook:57
#, no-c-format
msgid "Back references"
msgstr "Back references"

#. Tag: para
#: regular-expressions.docbook:60
#, no-c-format
msgid ""
"The caret (<literal>^</literal>) starting the expression is an assertion, "
"being true only if the following matching string is at the start of a line."
msgstr ""
"The caret (<literal>^</literal>) starting the expression is an assertion, "
"being true only if the following matching string is at the start of a line."

#. Tag: para
#: regular-expressions.docbook:64
#, fuzzy, no-c-format
#| msgid ""
#| "The stings <literal>[ \\t]</literal> and <literal>(Henrik|Pernille) sa(ys|"
#| "id)</literal> are patterns. The first one is a <emphasis>character class</"
#| "emphasis> that matches either a blank or a (horizontal) tab character; "
#| "the other pattern contains first a subpattern matching either "
#| "<literal>Henrik</literal> <emphasis>or</emphasis> <literal>Pernille</"
#| "literal>, then a piece matching the exact string <literal> sa</literal> "
#| "and finally a subpattern matching either <literal>ys</literal> "
#| "<emphasis>or</emphasis> <literal>id</literal>"
msgid ""
"The strings <literal>[ \\t]</literal> and <literal>(Henrik|Pernille) sa(ys|"
"id)</literal> are patterns. The first one is a <emphasis>character class</"
"emphasis> that matches either a blank or a (horizontal) tab character; the "
"other pattern contains first a subpattern matching either <literal>Henrik</"
"literal> <emphasis>or</emphasis> <literal>Pernille</literal>, then a piece "
"matching the exact string <literal> sa</literal> and finally a subpattern "
"matching either <literal>ys</literal> <emphasis>or</emphasis> <literal>id</"
"literal>"
msgstr ""
"The stings <literal>[ \\t]</literal> and <literal>(Henrik|Pernille) sa(ys|"
"id)</literal> are patterns. The first one is a <emphasis>character class</"
"emphasis> that matches either a blank or a (horizontal) tab character; the "
"other pattern contains first a subpattern matching either <literal>Henrik</"
"literal> <emphasis>or</emphasis> <literal>Pernille</literal>, then a piece "
"matching the exact string <literal> sa</literal> and finally a subpattern "
"matching either <literal>ys</literal> <emphasis>or</emphasis> <literal>id</"
"literal>"

#. Tag: para
#: regular-expressions.docbook:74
#, no-c-format
msgid ""
"The string <literal>{0,4}</literal> is a quantifier saying <quote>anywhere "
"from 0 up to 4 of the previous</quote>."
msgstr ""
"The string <literal>{0,4}</literal> is a quantifier saying <quote>anywhere "
"from 0 up to 4 of the previous</quote>."

#. Tag: para
#: regular-expressions.docbook:77
#, no-c-format
msgid ""
"Because regular expression software supporting the concept of <emphasis>back "
"references</emphasis> saves the entire matching part of the string as well "
"as sub-patterns enclosed in parentheses, given some means of access to those "
"references, we could get our hands on either the whole match (when searching "
"a text document in an editor with a regular expression, that is often marked "
"as selected) or either the name found, or the last part of the verb."
msgstr ""
"Because regular expression software supporting the concept of <emphasis>back "
"references</emphasis> saves the entire matching part of the string as well "
"as sub-patterns enclosed in parentheses, given some means of access to those "
"references, we could get our hands on either the whole match (when searching "
"a text document in an editor with a regular expression, that is often marked "
"as selected) or either the name found, or the last part of the verb."

#. Tag: para
#: regular-expressions.docbook:85
#, no-c-format
msgid ""
"All together, the expression will match where we wanted it to, and only "
"there."
msgstr ""
"All together, the expression will match where we wanted it to, and only "
"there."

#. Tag: para
#: regular-expressions.docbook:88
#, no-c-format
msgid ""
"The following sections will describe in details how to construct and use "
"patterns, character classes, assertions, quantifiers and back references, "
"and the final section will give a few useful examples."
msgstr ""
"The following sections will describe in details how to construct and use "
"patterns, character classes, assertions, quantifiers and back references, "
"and the final section will give a few useful examples."

#. Tag: title
#: regular-expressions.docbook:97
#, no-c-format
msgid "<title>Patterns</title>"
msgstr "<title>Patterns</title>"

#. Tag: para
#: regular-expressions.docbook:99
#, no-c-format
msgid ""
"Patterns consists of literal strings and character classes. Patterns may "
"contain sub-patterns, which are patterns enclosed in parentheses."
msgstr ""
"Patterns consists of literal strings and character classes. Patterns may "
"contain sub-patterns, which are patterns enclosed in parentheses."

#. Tag: title
#: regular-expressions.docbook:104
#, no-c-format
msgid "Escaping characters"
msgstr "Escaping characters"

#. Tag: para
#: regular-expressions.docbook:106
#, no-c-format
msgid ""
"In patterns as well as in character classes, some characters have a special "
"meaning. To literally match any of those characters, they must be marked or "
"<emphasis>escaped</emphasis> to let the regular expression software know "
"that it should interpret such characters in their literal meaning."
msgstr ""
"In patterns as well as in character classes, some characters have a special "
"meaning. To literally match any of those characters, they must be marked or "
"<emphasis>escaped</emphasis> to let the regular expression software know "
"that it should interpret such characters in their literal meaning."

#. Tag: para
#: regular-expressions.docbook:112
#, no-c-format
msgid ""
"This is done by prepending the character with a backslash (<literal>\\</"
"literal>)."
msgstr ""
"This is done by prepending the character with a backslash (<literal>\\</"
"literal>)."

#. Tag: para
#: regular-expressions.docbook:116
#, no-c-format
msgid ""
"The regular expression software will silently ignore escaping a character "
"that does not have any special meaning in the context, so escaping for "
"example a <quote>j</quote> (<userinput>\\j</userinput>) is safe. If you are "
"in doubt whether a character could have a special meaning, you can therefore "
"escape it safely."
msgstr ""
"The regular expression software will silently ignore escaping a character "
"that does not have any special meaning in the context, so escaping for "
"example a <quote>j</quote> (<userinput>\\j</userinput>) is safe. If you are "
"in doubt whether a character could have a special meaning, you can therefore "
"escape it safely."

#. Tag: para
#: regular-expressions.docbook:122
#, fuzzy, no-c-format
msgid ""
"Escaping of course includes the backslash character itself, to literally "
"match a such, you would write <userinput>\\\\</userinput>."
msgstr ""
"Escaping of cause includes the backslash character it self, to literally "
"match a such, you would write <userinput>\\\\</userinput>."

#. Tag: title
#: regular-expressions.docbook:129
#, no-c-format
msgid "Character Classes and abbreviations"
msgstr "Character Classes and abbreviations"

#. Tag: para
#: regular-expressions.docbook:131
#, no-c-format
msgid ""
"A <emphasis>character class</emphasis> is an expression that matches one of "
"a defined set of characters. In Regular Expressions, character classes are "
"defined by putting the legal characters for the class in square brackets, "
"<literal>[]</literal>, or by using one of the abbreviated classes described "
"below."
msgstr ""
"A <emphasis>character class</emphasis> is an expression that matches one of "
"a defined set of characters. In Regular Expressions, character classes are "
"defined by putting the legal characters for the class in square brackets, "
"<literal>[]</literal>, or by using one of the abbreviated classes described "
"below."

#. Tag: para
#: regular-expressions.docbook:137
#, no-c-format
msgid ""
"Simple character classes just contains one or more literal characters, for "
"example <userinput>[abc]</userinput> (matching either of the letters "
"<quote>a</quote>, <quote>b</quote> or <quote>c</quote>) or "
"<userinput>[0123456789]</userinput> (matching any digit)."
msgstr ""
"Simple character classes just contains one or more literal characters, for "
"example <userinput>[abc]</userinput> (matching either of the letters "
"<quote>a</quote>, <quote>b</quote> or <quote>c</quote>) or "
"<userinput>[0123456789]</userinput> (matching any digit)."

#. Tag: para
#: regular-expressions.docbook:142
#, fuzzy, no-c-format
msgid ""
"Because letters and digits have a logical order, you can abbreviate those by "
"specifying ranges of them: <userinput>[a-c]</userinput> is equal to "
"<userinput>[abc]</userinput> and <userinput>[0-9]</userinput> is equal to "
"<userinput>[0123456789]</userinput>. Combining these constructs, for example "
"<userinput>[a-fynot1-38]</userinput> is completely legal (the last one would "
"match, of course, either of <quote>a</quote>,<quote>b</quote>,<quote>c</"
"quote>,<quote>d</quote>, <quote>e</quote>,<quote>f</quote>,<quote>y</quote>,"
"<quote>n</quote>,<quote>o</quote>,<quote>t</quote>, <quote>1</quote>,"
"<quote>2</quote>,<quote>3</quote> or <quote>8</quote>)."
msgstr ""
"Because letters and digits have a logical order, you can abbreviate those by "
"specifying ranges of them: <userinput>[a-c]</userinput> is equal to "
"<userinput>[abc]</userinput> and <userinput>[0-9]</userinput> is equal to "
"<userinput>[0123456789]</userinput>. Combining these constructs, for example "
"<userinput>[a-fynot1-38]</userinput> is completely legal (the last one would "
"match, of cause, either of <quote>a</quote>,<quote>b</quote>,<quote>c</"
"quote>,<quote>d</quote>, <quote>e</quote>,<quote>f</quote>,<quote>y</quote>,"
"<quote>n</quote>,<quote>o</quote>,<quote>t</quote>, <quote>1</quote>,"
"<quote>2</quote>,<quote>3</quote> or <quote>8</quote>)."

#. Tag: para
#: regular-expressions.docbook:154
#, no-c-format
msgid ""
"As capital letters are different characters from their non-capital "
"equivalents, to create a caseless character class matching <quote>a</quote> "
"or <quote>b</quote>, in any case, you need to write it <userinput>[aAbB]</"
"userinput>."
msgstr ""
"As capital letters are different characters from their non-capital "
"equivalents, to create a caseless character class matching <quote>a</quote> "
"or <quote>b</quote>, in any case, you need to write it <userinput>[aAbB]</"
"userinput>."

#. Tag: para
#: regular-expressions.docbook:159
#, fuzzy, no-c-format
msgid ""
"It is of course possible to create a <quote>negative</quote> class matching "
"as <quote>anything but</quote> To do so put a caret (<literal>^</literal>) "
"at the beginning of the class:"
msgstr ""
"It is of cause possible to create a <quote>negative</quote> class matching "
"as <quote>anything but</quote> To do so put a caret (<literal>^</literal>) "
"at the beginning of the class:"

#. Tag: para
#: regular-expressions.docbook:163
#, no-c-format
msgid ""
"<userinput>[^abc]</userinput> will match any character <emphasis>but</"
"emphasis> <quote>a</quote>, <quote>b</quote> or <quote>c</quote>."
msgstr ""
"<userinput>[^abc]</userinput> will match any character <emphasis>but</"
"emphasis> <quote>a</quote>, <quote>b</quote> or <quote>c</quote>."

#. Tag: para
#: regular-expressions.docbook:167
#, no-c-format
msgid ""
"In addition to literal characters, some abbreviations are defined, making "
"life still a bit easier:"
msgstr ""
"In addition to literal characters, some abbreviations are defined, making "
"life still a bit easier:"

#. Tag: userinput
#: regular-expressions.docbook:173
#, no-c-format
msgid "<userinput>\\a</userinput>"
msgstr "<userinput>\\a</userinput>"

#. Tag: para
#: regular-expressions.docbook:174
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the <acronym>ASCII</acronym> bell character (BEL, 0x07)."
msgid "This matches the &ASCII; bell character (BEL, 0x07)."
msgstr "This matches the <acronym>ASCII</acronym> bell character (BEL, 0x07)."

#. Tag: userinput
#: regular-expressions.docbook:178
#, no-c-format
msgid "<userinput>\\f</userinput>"
msgstr "<userinput>\\f</userinput>"

#. Tag: para
#: regular-expressions.docbook:179
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the <acronym>ASCII</acronym> form feed character (FF, 0x0C)."
msgid "This matches the &ASCII; form feed character (FF, 0x0C)."
msgstr ""
"This matches the <acronym>ASCII</acronym> form feed character (FF, 0x0C)."

#. Tag: userinput
#: regular-expressions.docbook:183
#, no-c-format
msgid "<userinput>\\n</userinput>"
msgstr "<userinput>\\n</userinput>"

#. Tag: para
#: regular-expressions.docbook:184
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the <acronym>ASCII</acronym> line feed character (LF, 0x0A, "
#| "Unix newline)."
msgid "This matches the &ASCII; line feed character (LF, 0x0A, Unix newline)."
msgstr ""
"This matches the <acronym>ASCII</acronym> line feed character (LF, 0x0A, "
"Unix newline)."

#. Tag: userinput
#: regular-expressions.docbook:188
#, no-c-format
msgid "<userinput>\\r</userinput>"
msgstr "<userinput>\\r</userinput>"

#. Tag: para
#: regular-expressions.docbook:189
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the <acronym>ASCII</acronym> carriage return character (CR, "
#| "0x0D)."
msgid "This matches the &ASCII; carriage return character (CR, 0x0D)."
msgstr ""
"This matches the <acronym>ASCII</acronym> carriage return character (CR, "
"0x0D)."

#. Tag: userinput
#: regular-expressions.docbook:193
#, no-c-format
msgid "<userinput>\\t</userinput>"
msgstr "<userinput>\\t</userinput>"

#. Tag: para
#: regular-expressions.docbook:194
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the <acronym>ASCII</acronym> horizontal tab character (HT, "
#| "0x09)."
msgid "This matches the &ASCII; horizontal tab character (HT, 0x09)."
msgstr ""
"This matches the <acronym>ASCII</acronym> horizontal tab character (HT, "
"0x09)."

#. Tag: userinput
#: regular-expressions.docbook:198
#, no-c-format
msgid "<userinput>\\v</userinput>"
msgstr "<userinput>\\v</userinput>"

#. Tag: para
#: regular-expressions.docbook:199
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the <acronym>ASCII</acronym> vertical tab character (VT, "
#| "0x0B)."
msgid "This matches the &ASCII; vertical tab character (VT, 0x0B)."
msgstr ""
"This matches the <acronym>ASCII</acronym> vertical tab character (VT, 0x0B)."

#. Tag: userinput
#: regular-expressions.docbook:202
#, no-c-format
msgid "\\xhhhh"
msgstr "\\xhhhh"

#. Tag: para
#: regular-expressions.docbook:204
#, fuzzy, no-c-format
#| msgid ""
#| "This matches the Unicode character corresponding to the hexadecimal "
#| "number hhhh (between 0x0000 and 0xFFFF). \\0ooo (&ie;, \\zero ooo) "
#| "matches the <acronym>ASCII</acronym>/Latin-1 character corresponding to "
#| "the octal number ooo (between 0 and 0377)."
msgid ""
"This matches the Unicode character corresponding to the hexadecimal number "
"hhhh (between 0x0000 and 0xFFFF). \\0ooo (&ie;, \\zero ooo) matches the "
"&ASCII;/Latin-1 character corresponding to the octal number ooo (between 0 "
"and 0377)."
msgstr ""
"This matches the Unicode character corresponding to the hexadecimal number "
"hhhh (between 0x0000 and 0xFFFF). \\0ooo (&ie;, \\zero ooo) matches the "
"<acronym>ASCII</acronym>/Latin-1 character corresponding to the octal number "
"ooo (between 0 and 0377)."

#. Tag: term
#: regular-expressions.docbook:212
#, no-c-format
msgid "<userinput>.</userinput> (dot)"
msgstr "<userinput>.</userinput> (dot)"

#. Tag: para
#: regular-expressions.docbook:213
#, no-c-format
msgid "This matches any character (including newline)."
msgstr "This matches any character (including newline)."

#. Tag: userinput
#: regular-expressions.docbook:217
#, no-c-format
msgid "<userinput>\\d</userinput>"
msgstr "<userinput>\\d</userinput>"

#. Tag: para
#: regular-expressions.docbook:218
#, no-c-format
msgid "This matches a digit. Equal to <literal>[0-9]</literal>"
msgstr "This matches a digit. Equal to <literal>[0-9]</literal>"

#. Tag: userinput
#: regular-expressions.docbook:222
#, no-c-format
msgid "<userinput>\\D</userinput>"
msgstr "<userinput>\\D</userinput>"

#. Tag: para
#: regular-expressions.docbook:223
#, no-c-format
msgid ""
"This matches a non-digit. Equal to <literal>[^0-9]</literal> or <literal>[^"
"\\d]</literal>"
msgstr ""
"This matches a non-digit. Equal to <literal>[^0-9]</literal> or <literal>[^"
"\\d]</literal>"

#. Tag: userinput
#: regular-expressions.docbook:227
#, no-c-format
msgid "<userinput>\\s</userinput>"
msgstr "<userinput>\\s</userinput>"

#. Tag: para
#: regular-expressions.docbook:228
#, no-c-format
msgid ""
"This matches a whitespace character. Practically equal to <literal>[ \\t\\n"
"\\r]</literal>"
msgstr ""
"This matches a whitespace character. Practically equal to <literal>[ \\t\\n"
"\\r]</literal>"

#. Tag: userinput
#: regular-expressions.docbook:232
#, no-c-format
msgid "<userinput>\\S</userinput>"
msgstr "<userinput>\\S</userinput>"

#. Tag: para
#: regular-expressions.docbook:233
#, no-c-format
msgid ""
"This matches a non-whitespace. Practically equal to <literal>[^ \\t\\r\\n]</"
"literal>, and equal to <literal>[^\\s]</literal>"
msgstr ""
"This matches a non-whitespace. Practically equal to <literal>[^ \\t\\r\\n]</"
"literal>, and equal to <literal>[^\\s]</literal>"

#. Tag: userinput
#: regular-expressions.docbook:237
#, no-c-format
msgid "<userinput>\\w</userinput>"
msgstr "<userinput>\\w</userinput>"

#. Tag: para
#: regular-expressions.docbook:238
#, fuzzy, no-c-format
#| msgid ""
#| "Matches any <quote>word character</quote> - in this case any letter or "
#| "digit. Note that underscore (<literal>_</literal>) is not matched, as is "
#| "the case with perl regular expressions. Equal to <literal>[a-zA-Z0-9]</"
#| "literal>"
msgid ""
"Matches any <quote>word character</quote> - in this case any letter, digit "
"or underscore. Equal to <literal>[a-zA-Z0-9_]</literal>"
msgstr ""
"Matches any <quote>word character</quote> - in this case any letter or "
"digit. Note that underscore (<literal>_</literal>) is not matched, as is the "
"case with perl regular expressions. Equal to <literal>[a-zA-Z0-9]</literal>"

#. Tag: userinput
#: regular-expressions.docbook:243
#, no-c-format
msgid "<userinput>\\W</userinput>"
msgstr "<userinput>\\W</userinput>"

#. Tag: para
#: regular-expressions.docbook:244
#, fuzzy, no-c-format
#| msgid ""
#| "Matches any non-word character - anything but letters or numbers. Equal "
#| "to <literal>[^a-zA-Z0-9]</literal> or <literal>[^\\w]</literal>"
msgid ""
"Matches any non-word character - anything but letters, numbers or "
"underscore. Equal to <literal>[^a-zA-Z0-9_]</literal> or <literal>[^\\w]</"
"literal>"
msgstr ""
"Matches any non-word character - anything but letters or numbers. Equal to "
"<literal>[^a-zA-Z0-9]</literal> or <literal>[^\\w]</literal>"

#. Tag: para
#: regular-expressions.docbook:253
#, no-c-format
msgid ""
"The <emphasis>POSIX notation of classes</emphasis>, <userinput>[:&lt;class "
"name&gt;:]</userinput> are also supported. For example, <userinput>[:"
"digit:]</userinput> is equivalent to <userinput>\\d</userinput>, and "
"<userinput>[:space:]</userinput> to <userinput>\\s</userinput>. See the full "
"list of POSIX character classes <ulink url=\"https://www.regular-expressions."
"info/posixbrackets.html\">here</ulink>."
msgstr ""

#. Tag: para
#: regular-expressions.docbook:260
#, no-c-format
msgid ""
"The abbreviated classes can be put inside a custom class, for example to "
"match a word character, a blank or a dot, you could write <userinput>[\\w "
"\\.]</userinput>"
msgstr ""
"The abbreviated classes can be put inside a custom class, for example to "
"match a word character, a blank or a dot, you could write <userinput>[\\w "
"\\.]</userinput>"

#. Tag: title
#: regular-expressions.docbook:265
#, no-c-format
msgid "Characters with special meanings inside character classes"
msgstr "Characters with special meanings inside character classes"

#. Tag: para
#: regular-expressions.docbook:267
#, no-c-format
msgid ""
"The following characters has a special meaning inside the <quote>[]</quote> "
"character class construct, and must be escaped to be literally included in a "
"class:"
msgstr ""
"The following characters has a special meaning inside the <quote>[]</quote> "
"character class construct, and must be escaped to be literally included in a "
"class:"

#. Tag: userinput
#: regular-expressions.docbook:273
#, no-c-format
msgid "<userinput>]</userinput>"
msgstr "<userinput>]</userinput>"

#. Tag: para
#: regular-expressions.docbook:274
#, fuzzy, no-c-format
#| msgid ""
#| "Ends the character class. Must be escaped unless it is the very first "
#| "character in the class (may follow an unescaped caret)"
msgid ""
"Ends the character class. Must be escaped unless it is the very first "
"character in the class (may follow an unescaped caret)."
msgstr ""
"Ends the character class. Must be escaped unless it is the very first "
"character in the class (may follow an unescaped caret)"

#. Tag: term
#: regular-expressions.docbook:278 regular-expressions.docbook:415
#, no-c-format
msgid "<userinput>^</userinput> (caret)"
msgstr "<userinput>^</userinput> (caret)"

#. Tag: para
#: regular-expressions.docbook:279
#, no-c-format
msgid ""
"Denotes a negative class, if it is the first character. Must be escaped to "
"match literally if it is the first character in the class."
msgstr ""
"Denotes a negative class, if it is the first character. Must be escaped to "
"match literally if it is the first character in the class."

#. Tag: term
#: regular-expressions.docbook:282
#, no-c-format
msgid "<userinput>-</userinput> (dash)"
msgstr "<userinput>-</userinput> (dash)"

#. Tag: para
#: regular-expressions.docbook:283
#, no-c-format
msgid ""
"Denotes a logical range. Must always be escaped within a character class."
msgstr ""
"Denotes a logical range. Must always be escaped within a character class."

#. Tag: term
#: regular-expressions.docbook:286 regular-expressions.docbook:410
#, no-c-format
msgid "<userinput>\\</userinput> (backslash)"
msgstr "<userinput>\\</userinput> (backslash)"

#. Tag: para
#: regular-expressions.docbook:287
#, no-c-format
msgid "The escape character. Must always be escaped."
msgstr "The escape character. Must always be escaped."

#. Tag: title
#: regular-expressions.docbook:298
#, no-c-format
msgid "Alternatives: matching <quote>one of</quote>"
msgstr "Alternatives: matching <quote>one of</quote>"

#. Tag: para
#: regular-expressions.docbook:300
#, no-c-format
msgid ""
"If you want to match one of a set of alternative patterns, you can separate "
"those with <literal>|</literal> (vertical bar character)."
msgstr ""
"If you want to match one of a set of alternative patterns, you can separate "
"those with <literal>|</literal> (vertical bar character)."

#. Tag: para
#: regular-expressions.docbook:303
#, no-c-format
msgid ""
"For example to find either <quote>John</quote> or <quote>Harry</quote> you "
"would use an expression <userinput>John|Harry</userinput>."
msgstr ""
"For example to find either <quote>John</quote> or <quote>Harry</quote> you "
"would use an expression <userinput>John|Harry</userinput>."

#. Tag: title
#: regular-expressions.docbook:309
#, no-c-format
msgid "Sub Patterns"
msgstr "Sub Patterns"

#. Tag: para
#: regular-expressions.docbook:311
#, no-c-format
msgid ""
"<emphasis>Sub patterns</emphasis> are patterns enclosed in parentheses, and "
"they have several uses in the world of regular expressions."
msgstr ""
"<emphasis>Sub patterns</emphasis> are patterns enclosed in parentheses, and "
"they have several uses in the world of regular expressions."

#. Tag: title
#: regular-expressions.docbook:317
#, no-c-format
msgid "Specifying alternatives"
msgstr "Specifying alternatives"

#. Tag: para
#: regular-expressions.docbook:319
#, no-c-format
msgid ""
"You may use a sub pattern to group a set of alternatives within a larger "
"pattern. The alternatives are separated by the character <quote>|</quote> "
"(vertical bar)."
msgstr ""
"You may use a sub pattern to group a set of alternatives within a larger "
"pattern. The alternatives are separated by the character <quote>|</quote> "
"(vertical bar)."

#. Tag: para
#: regular-expressions.docbook:323
#, no-c-format
msgid ""
"For example to match either of the words <quote>int</quote>, <quote>float</"
"quote> or <quote>double</quote>, you could use the pattern <userinput>int|"
"float|double</userinput>. If you only want to find one if it is followed by "
"some whitespace and then some letters, put the alternatives inside a "
"subpattern: <userinput>(int|float|double)\\s+\\w+</userinput>."
msgstr ""
"For example to match either of the words <quote>int</quote>, <quote>float</"
"quote> or <quote>double</quote>, you could use the pattern <userinput>int|"
"float|double</userinput>. If you only want to find one if it is followed by "
"some whitespace and then some letters, put the alternatives inside a "
"subpattern: <userinput>(int|float|double)\\s+\\w+</userinput>."

#. Tag: title
#: regular-expressions.docbook:334
#, no-c-format
msgid "Capturing matching text (back references)"
msgstr "Capturing matching text (back references)"

#. Tag: para
#: regular-expressions.docbook:336
#, no-c-format
msgid ""
"If you want to use a back reference, use a sub pattern <userinput>(PATTERN)</"
"userinput> to have the desired part of the pattern remembered. To prevent "
"the sub pattern from being remembered, use a non-capturing group "
"<userinput>(?:PATTERN)</userinput>."
msgstr ""

#. Tag: para
#: regular-expressions.docbook:341
#, fuzzy, no-c-format
#| msgid ""
#| "For example, it you want to find two occurrences of the same word "
#| "separated by a comma and possibly some whitespace, you could write "
#| "<userinput>(\\w+),\\s*\\1</userinput>. The sub pattern <literal>\\w+</"
#| "literal> would find a chunk of word characters, and the entire expression "
#| "would match if those were followed by a comma, 0 or more whitespace and "
#| "then an equal chunk of word characters. (The string <literal>\\1</"
#| "literal> references <emphasis>the first sub pattern enclosed in "
#| "parentheses</emphasis>)"
msgid ""
"For example, if you want to find two occurrences of the same word separated "
"by a comma and possibly some whitespace, you could write <userinput>(\\w+),"
"\\s*\\1</userinput>. The sub pattern <literal>\\w+</literal> would find a "
"chunk of word characters, and the entire expression would match if those "
"were followed by a comma, 0 or more whitespace and then an equal chunk of "
"word characters. (The string <literal>\\1</literal> references <emphasis>the "
"first sub pattern enclosed in parentheses</emphasis>.)"
msgstr ""
"For example, it you want to find two occurrences of the same word separated "
"by a comma and possibly some whitespace, you could write <userinput>(\\w+),"
"\\s*\\1</userinput>. The sub pattern <literal>\\w+</literal> would find a "
"chunk of word characters, and the entire expression would match if those "
"were followed by a comma, 0 or more whitespace and then an equal chunk of "
"word characters. (The string <literal>\\1</literal> references <emphasis>the "
"first sub pattern enclosed in parentheses</emphasis>)"

#. Tag: para
#: regular-expressions.docbook:351
#, no-c-format
msgid ""
"To avoid ambiguities with usage of <userinput>\\1</userinput> with some "
"digits behind it (&eg; <userinput>\\12</userinput> can be 12th subpattern or "
"just the first subpattern with <userinput>2</userinput>) we use <userinput>"
"\\{12}</userinput> as syntax for multi-digit subpatterns."
msgstr ""

#. Tag: para
#: regular-expressions.docbook:352
#, no-c-format
msgid "Examples:"
msgstr ""

#. Tag: para
#: regular-expressions.docbook:354
#, no-c-format
msgid "<userinput>\\{12}1</userinput> is <quote>use subpattern 12</quote>"
msgstr ""

#. Tag: para
#: regular-expressions.docbook:355
#, no-c-format
msgid ""
"<userinput>\\123</userinput> is <quote>use capture 1 then 23 as the normal "
"text</quote>"
msgstr ""

#. Tag: title
#: regular-expressions.docbook:365
#, no-c-format
msgid "Lookahead Assertions"
msgstr "Lookahead Assertions"

#. Tag: para
#: regular-expressions.docbook:367
#, no-c-format
msgid ""
"A lookahead assertion is a sub pattern, starting with either <literal>?=</"
"literal> or <literal>?!</literal>."
msgstr ""
"A lookahead assertion is a sub pattern, starting with either <literal>?=</"
"literal> or <literal>?!</literal>."

#. Tag: para
#: regular-expressions.docbook:370
#, no-c-format
msgid ""
"For example to match the literal string <quote>Bill</quote> but only if not "
"followed by <quote> Gates</quote>, you could use this expression: "
"<userinput>Bill(?! Gates)</userinput>. (This would find <quote>Bill Clinton</"
"quote> as well as <quote>Billy the kid</quote>, but silently ignore the "
"other matches.)"
msgstr ""
"For example to match the literal string <quote>Bill</quote> but only if not "
"followed by <quote> Gates</quote>, you could use this expression: "
"<userinput>Bill(?! Gates)</userinput>. (This would find <quote>Bill Clinton</"
"quote> as well as <quote>Billy the kid</quote>, but silently ignore the "
"other matches.)"

#. Tag: para
#: regular-expressions.docbook:376 regular-expressions.docbook:393
#, no-c-format
msgid "Sub patterns used for assertions are not captured."
msgstr "Sub patterns used for assertions are not captured."

#. Tag: para
#: regular-expressions.docbook:378
#, fuzzy, no-c-format
#| msgid "See also <link linkend=\"assertions\">Assertions</link>"
msgid "See also <link linkend=\"assertions\">Assertions</link>."
msgstr "See also <link linkend=\"assertions\">Assertions</link>"

#. Tag: title
#: regular-expressions.docbook:383
#, fuzzy, no-c-format
#| msgid "Lookahead Assertions"
msgid "Lookbehind Assertions"
msgstr "Lookahead Assertions"

#. Tag: para
#: regular-expressions.docbook:385
#, fuzzy, no-c-format
#| msgid ""
#| "A lookahead assertion is a sub pattern, starting with either <literal>?=</"
#| "literal> or <literal>?!</literal>."
msgid ""
"A lookbehind assertion is a sub pattern, starting with either <literal>?&lt;"
"=</literal> or <literal>?&lt;!</literal>."
msgstr ""
"A lookahead assertion is a sub pattern, starting with either <literal>?=</"
"literal> or <literal>?!</literal>."

#. Tag: para
#: regular-expressions.docbook:388
#, no-c-format
msgid ""
"Lookbehind has the same effect as the lookahead, but works backwards. For "
"example to match the literal string <quote>fruit</quote> but only if not "
"preceded by <quote>grape</quote>, you could use this expression: "
"<userinput>(?&lt;!grape)fruit</userinput>."
msgstr ""

#. Tag: para
#: regular-expressions.docbook:395
#, no-c-format
msgid "See also <link linkend=\"assertions\">Assertions</link>"
msgstr "See also <link linkend=\"assertions\">Assertions</link>"

#. Tag: title
#: regular-expressions.docbook:402
#, no-c-format
msgid "Characters with a special meaning inside patterns"
msgstr "Characters with a special meaning inside patterns"

#. Tag: para
#: regular-expressions.docbook:404
#, no-c-format
msgid ""
"The following characters have meaning inside a pattern, and must be escaped "
"if you want to literally match them:"
msgstr ""
"The following characters have meaning inside a pattern, and must be escaped "
"if you want to literally match them:"

#. Tag: para
#: regular-expressions.docbook:411
#, no-c-format
msgid "The escape character."
msgstr "The escape character."

#. Tag: para
#: regular-expressions.docbook:416
#, no-c-format
msgid "Asserts the beginning of the string."
msgstr "Asserts the beginning of the string."

#. Tag: userinput
#: regular-expressions.docbook:420
#, no-c-format
msgid "<userinput>$</userinput>"
msgstr "<userinput>$</userinput>"

#. Tag: para
#: regular-expressions.docbook:421
#, no-c-format
msgid "Asserts the end of string."
msgstr "Asserts the end of string."

#. Tag: term
#: regular-expressions.docbook:425
#, no-c-format
msgid "<userinput>()</userinput> (left and right parentheses)"
msgstr "<userinput>()</userinput> (left and right parentheses)"

#. Tag: para
#: regular-expressions.docbook:426
#, no-c-format
msgid "Denotes sub patterns."
msgstr "Denotes sub patterns."

#. Tag: term
#: regular-expressions.docbook:430
#, no-c-format
msgid "<userinput>{}</userinput> (left and right curly braces)"
msgstr "<userinput>{}</userinput> (left and right curly braces)"

#. Tag: para
#: regular-expressions.docbook:431
#, no-c-format
msgid "Denotes numeric quantifiers."
msgstr "Denotes numeric quantifiers."

#. Tag: term
#: regular-expressions.docbook:435
#, no-c-format
msgid "<userinput>[]</userinput> (left and right square brackets)"
msgstr "<userinput>[]</userinput> (left and right square brackets)"

#. Tag: para
#: regular-expressions.docbook:436
#, no-c-format
msgid "Denotes character classes."
msgstr "Denotes character classes."

#. Tag: term
#: regular-expressions.docbook:440
#, no-c-format
msgid "<userinput>|</userinput> (vertical bar)"
msgstr "<userinput>|</userinput> (vertical bar)"

#. Tag: para
#: regular-expressions.docbook:441
#, no-c-format
msgid "logical OR. Separates alternatives."
msgstr "logical OR. Separates alternatives."

#. Tag: term
#: regular-expressions.docbook:445 regular-expressions.docbook:522
#, no-c-format
msgid "<userinput>+</userinput> (plus sign)"
msgstr "<userinput>+</userinput> (plus sign)"

#. Tag: para
#: regular-expressions.docbook:446
#, no-c-format
msgid "Quantifier, 1 or more."
msgstr "Quantifier, 1 or more."

#. Tag: term
#: regular-expressions.docbook:450 regular-expressions.docbook:517
#, no-c-format
msgid "<userinput>*</userinput> (asterisk)"
msgstr "<userinput>*</userinput> (asterisk)"

#. Tag: para
#: regular-expressions.docbook:451
#, no-c-format
msgid "Quantifier, 0 or more."
msgstr "Quantifier, 0 or more."

#. Tag: term
#: regular-expressions.docbook:455 regular-expressions.docbook:527
#, no-c-format
msgid "<userinput>?</userinput> (question mark)"
msgstr "<userinput>?</userinput> (question mark)"

#. Tag: para
#: regular-expressions.docbook:456
#, no-c-format
msgid "An optional character. Can be interpreted as a quantifier, 0 or 1."
msgstr "An optional character. Can be interpreted as a quantifier, 0 or 1."

#. Tag: title
#: regular-expressions.docbook:468
#, no-c-format
msgid "<title>Quantifiers</title>"
msgstr "<title>Quantifiers</title>"

#. Tag: para
#: regular-expressions.docbook:470
#, no-c-format
msgid ""
"<emphasis>Quantifiers</emphasis> allows a regular expression to match a "
"specified number or range of numbers of either a character, character class "
"or sub pattern."
msgstr ""
"<emphasis>Quantifiers</emphasis> allows a regular expression to match a "
"specified number or range of numbers of either a character, character class "
"or sub pattern."

#. Tag: para
#: regular-expressions.docbook:474
#, no-c-format
msgid ""
"Quantifiers are enclosed in curly brackets (<literal>{</literal> and "
"<literal>}</literal>) and have the general form <literal>{[minimum-"
"occurrences][,[maximum-occurrences]]}</literal>"
msgstr ""
"Quantifiers are enclosed in curly brackets (<literal>{</literal> and "
"<literal>}</literal>) and have the general form <literal>{[minimum-"
"occurrences][,[maximum-occurrences]]}</literal>"

#. Tag: para
#: regular-expressions.docbook:479
#, no-c-format
msgid "The usage is best explained by example:"
msgstr "The usage is best explained by example:"

#. Tag: userinput
#: regular-expressions.docbook:484
#, no-c-format
msgid "<userinput>{1}</userinput>"
msgstr "<userinput>{1}</userinput>"

#. Tag: para
#: regular-expressions.docbook:485
#, no-c-format
msgid "Exactly 1 occurrence"
msgstr "Exactly 1 occurrence"

#. Tag: userinput
#: regular-expressions.docbook:489
#, no-c-format
msgid "{0,1}"
msgstr "{0,1}"

#. Tag: para
#: regular-expressions.docbook:490
#, no-c-format
msgid "Zero or 1 occurrences"
msgstr "Zero or 1 occurrences"

#. Tag: userinput
#: regular-expressions.docbook:494
#, no-c-format
msgid "{,1}"
msgstr "{,1}"

#. Tag: para
#: regular-expressions.docbook:495
#, no-c-format
msgid "The same, with less work;)"
msgstr "The same, with less work;)"

#. Tag: userinput
#: regular-expressions.docbook:499
#, no-c-format
msgid "{5,10}"
msgstr "{5,10}"

#. Tag: para
#: regular-expressions.docbook:500
#, no-c-format
msgid "At least 5 but maximum 10 occurrences."
msgstr "At least 5 but maximum 10 occurrences."

#. Tag: userinput
#: regular-expressions.docbook:504
#, no-c-format
msgid "{5,}"
msgstr "{5,}"

#. Tag: para
#: regular-expressions.docbook:505
#, no-c-format
msgid "At least 5 occurrences, no maximum."
msgstr "At least 5 occurrences, no maximum."

#. Tag: para
#: regular-expressions.docbook:512
#, no-c-format
msgid "Additionally, there are some abbreviations:"
msgstr "Additionally, there are some abbreviations:"

#. Tag: para
#: regular-expressions.docbook:518
#, no-c-format
msgid "similar to <literal>{0,}</literal>, find any number of occurrences."
msgstr "similar to <literal>{0,}</literal>, find any number of occurrences."

#. Tag: para
#: regular-expressions.docbook:523
#, no-c-format
msgid "similar to <literal>{1,}</literal>, at least 1 occurrence."
msgstr "similar to <literal>{1,}</literal>, at least 1 occurrence."

#. Tag: para
#: regular-expressions.docbook:528
#, no-c-format
msgid "similar to <literal>{0,1}</literal>, zero or 1 occurrence."
msgstr "similar to <literal>{0,1}</literal>, zero or 1 occurrence."

#. Tag: title
#: regular-expressions.docbook:537
#, no-c-format
msgid "Greed"
msgstr "Greed"

#. Tag: para
#: regular-expressions.docbook:539
#, no-c-format
msgid ""
"When using quantifiers with no maximum, regular expressions defaults to "
"match as much of the searched string as possible, commonly known as "
"<emphasis>greedy</emphasis> behavior."
msgstr ""
"When using quantifiers with no maximum, regular expressions defaults to "
"match as much of the searched string as possible, commonly known as "
"<emphasis>greedy</emphasis> behaviour."

#. Tag: para
#: regular-expressions.docbook:543
#, no-c-format
msgid ""
"Modern regular expression software provides the means of <quote>turning off "
"greediness</quote>, though in a graphical environment it is up to the "
"interface to provide you with access to this feature. For example a search "
"dialog providing a regular expression search could have a check box labeled "
"<quote>Minimal matching</quote> as well as it ought to indicate if "
"greediness is the default behavior."
msgstr ""
"Modern regular expression software provides the means of <quote>turning off "
"greediness</quote>, though in a graphical environment it is up to the "
"interface to provide you with access to this feature. For example a search "
"dialogue providing a regular expression search could have a check box "
"labelled <quote>Minimal matching</quote> as well as it ought to indicate if "
"greediness is the default behaviour."

#. Tag: title
#: regular-expressions.docbook:554
#, no-c-format
msgid "In context examples"
msgstr "In context examples"

#. Tag: para
#: regular-expressions.docbook:556
#, fuzzy, no-c-format
#| msgid "Here are a few examples of using quantifiers"
msgid "Here are a few examples of using quantifiers:"
msgstr "Here are a few examples of using quantifiers"

#. Tag: userinput
#: regular-expressions.docbook:561
#, no-c-format
msgid "^\\d{4,5}\\s"
msgstr "^\\d{4,5}\\s"

#. Tag: para
#: regular-expressions.docbook:562
#, fuzzy, no-c-format
#| msgid ""
#| "Matches the digits in <quote>1234 go</quote> and <quote>12345 now</"
#| "quote>, but neither in <quote>567 eleven</quote> nor in <quote>223459 "
#| "somewhere</quote>"
msgid ""
"Matches the digits in <quote>1234 go</quote> and <quote>12345 now</quote>, "
"but neither in <quote>567 eleven</quote> nor in <quote>223459 somewhere</"
"quote>."
msgstr ""
"Matches the digits in <quote>1234 go</quote> and <quote>12345 now</quote>, "
"but neither in <quote>567 eleven</quote> nor in <quote>223459 somewhere</"
"quote>"

#. Tag: userinput
#: regular-expressions.docbook:567
#, no-c-format
msgid "<userinput>\\s+</userinput>"
msgstr "<userinput>\\s+</userinput>"

#. Tag: para
#: regular-expressions.docbook:568
#, fuzzy, no-c-format
#| msgid "Matches one or more whitespace characters"
msgid "Matches one or more whitespace characters."
msgstr "Matches one or more whitespace characters"

#. Tag: userinput
#: regular-expressions.docbook:572
#, no-c-format
msgid "(bla){1,}"
msgstr "(bla){1,}"

#. Tag: para
#: regular-expressions.docbook:573
#, fuzzy, no-c-format
#| msgid ""
#| "Matches all of <quote>blablabla</quote> and the <quote>bla</quote> in "
#| "<quote>blackbird</quote> or <quote>tabla</quote>"
msgid ""
"Matches all of <quote>blablabla</quote> and the <quote>bla</quote> in "
"<quote>blackbird</quote> or <quote>tabla</quote>."
msgstr ""
"Matches all of <quote>blablabla</quote> and the <quote>bla</quote> in "
"<quote>blackbird</quote> or <quote>tabla</quote>"

#. Tag: userinput
#: regular-expressions.docbook:577
#, no-c-format
msgid "/?&gt;"
msgstr "/?&gt;"

#. Tag: para
#: regular-expressions.docbook:578
#, no-c-format
msgid ""
"Matches <quote>/&gt;</quote> in <quote>&lt;closeditem/&gt;</quote> as well "
"as <quote>&gt;</quote> in <quote>&lt;openitem&gt;</quote>."
msgstr ""
"Matches <quote>/&gt;</quote> in <quote>&lt;closeditem/&gt;</quote> as well "
"as <quote>&gt;</quote> in <quote>&lt;openitem&gt;</quote>."

#. Tag: title
#: regular-expressions.docbook:589
#, no-c-format
msgid "<title>Assertions</title>"
msgstr "<title>Assertions</title>"

#. Tag: para
#: regular-expressions.docbook:591
#, no-c-format
msgid ""
"<emphasis>Assertions</emphasis> allows a regular expression to match only "
"under certain controlled conditions."
msgstr ""
"<emphasis>Assertions</emphasis> allows a regular expression to match only "
"under certain controlled conditions."

#. Tag: para
#: regular-expressions.docbook:594
#, no-c-format
msgid ""
"An assertion does not need a character to match, it rather investigates the "
"surroundings of a possible match before acknowledging it. For example the "
"<emphasis>word boundary</emphasis> assertion does not try to find a non word "
"character opposite a word one at its position, instead it makes sure that "
"there is not a word character. This means that the assertion can match where "
"there is no character, &ie; at the ends of a searched string."
msgstr ""
"An assertion does not need a character to match, it rather investigates the "
"surroundings of a possible match before acknowledging it. For example the "
"<emphasis>word boundary</emphasis> assertion does not try to find a non word "
"character opposite a word one at its position, instead it makes sure that "
"there is not a word character. This means that the assertion can match where "
"there is no character, &ie; at the ends of a searched string."

#. Tag: para
#: regular-expressions.docbook:602
#, fuzzy, no-c-format
msgid ""
"Some assertions actually do have a pattern to match, but the part of the "
"string matching that will not be a part of the result of the match of the "
"full expression."
msgstr ""
"Some assertions actually does have a pattern to match, but the part of the "
"string matching that will not be a part of the result of the match of the "
"full expression."

#. Tag: para
#: regular-expressions.docbook:606
#, no-c-format
msgid ""
"Regular Expressions as documented here supports the following assertions:"
msgstr ""
"Regular Expressions as documented here supports the following assertions:"

#. Tag: term
#: regular-expressions.docbook:612
#, no-c-format
msgid "<userinput>^</userinput> (caret: beginning of string)"
msgstr "<userinput>^</userinput> (caret: beginning of string)"

#. Tag: para
#: regular-expressions.docbook:614
#, no-c-format
msgid "Matches the beginning of the searched string."
msgstr "Matches the beginning of the searched string."

#. Tag: para
#: regular-expressions.docbook:615
#, no-c-format
msgid ""
"The expression <userinput>^Peter</userinput> will match at <quote>Peter</"
"quote> in the string <quote>Peter, hey!</quote> but not in <quote>Hey, Peter!"
"</quote>"
msgstr ""
"The expression <userinput>^Peter</userinput> will match at <quote>Peter</"
"quote> in the string <quote>Peter, hey!</quote> but not in <quote>Hey, Peter!"
"</quote>"

#. Tag: term
#: regular-expressions.docbook:621
#, no-c-format
msgid "<userinput>$</userinput> (end of string)"
msgstr "<userinput>$</userinput> (end of string)"

#. Tag: para
#: regular-expressions.docbook:622
#, no-c-format
msgid "Matches the end of the searched string."
msgstr "Matches the end of the searched string."

#. Tag: para
#: regular-expressions.docbook:624
#, no-c-format
msgid ""
"The expression <userinput>you\\?$</userinput> will match at the last you in "
"the string <quote>You didn't do that, did you?</quote> but nowhere in "
"<quote>You didn't do that, right?</quote>"
msgstr ""
"The expression <userinput>you\\?$</userinput> will match at the last you in "
"the string <quote>You didn't do that, did you?</quote> but nowhere in "
"<quote>You didn't do that, right?</quote>"

#. Tag: term
#: regular-expressions.docbook:632
#, no-c-format
msgid "<userinput>\\b</userinput> (word boundary)"
msgstr "<userinput>\\b</userinput> (word boundary)"

#. Tag: para
#: regular-expressions.docbook:633
#, no-c-format
msgid ""
"Matches if there is a word character at one side and not a word character at "
"the other."
msgstr ""
"Matches if there is a word character at one side and not a word character at "
"the other."

#. Tag: para
#: regular-expressions.docbook:635
#, no-c-format
msgid ""
"This is useful to find word ends, for example both ends to find a whole "
"word. The expression <userinput>\\bin\\b</userinput> will match at the "
"separate <quote>in</quote> in the string <quote>He came in through the "
"window</quote>, but not at the <quote>in</quote> in <quote>window</quote>."
msgstr ""
"This is useful to find word ends, for example both ends to find a whole "
"word. The expression <userinput>\\bin\\b</userinput> will match at the "
"separate <quote>in</quote> in the string <quote>He came in through the "
"window</quote>, but not at the <quote>in</quote> in <quote>window</quote>."

#. Tag: term
#: regular-expressions.docbook:644
#, no-c-format
msgid "<userinput>\\B</userinput> (non word boundary)"
msgstr "<userinput>\\B</userinput> (non word boundary)"

#. Tag: para
#: regular-expressions.docbook:645
#, no-c-format
msgid "Matches wherever <quote>\\b</quote> does not."
msgstr "Matches wherever <quote>\\b</quote> does not."

#. Tag: para
#: regular-expressions.docbook:646
#, no-c-format
msgid ""
"That means that it will match for example within words: The expression "
"<userinput>\\Bin\\B</userinput> will match at in <quote>window</quote> but "
"not in <quote>integer</quote> or <quote>I'm in love</quote>."
msgstr ""
"That means that it will match for example within words: The expression "
"<userinput>\\Bin\\B</userinput> will match at in <quote>window</quote> but "
"not in <quote>integer</quote> or <quote>I'm in love</quote>."

#. Tag: term
#: regular-expressions.docbook:652
#, no-c-format
msgid "<userinput>(?=PATTERN)</userinput> (Positive lookahead)"
msgstr "<userinput>(?=PATTERN)</userinput> (Positive lookahead)"

#. Tag: para
#: regular-expressions.docbook:653
#, no-c-format
msgid ""
"A lookahead assertion looks at the part of the string following a possible "
"match. The positive lookahead will prevent the string from matching if the "
"text following the possible match does not match the <emphasis>PATTERN</"
"emphasis> of the assertion, but the text matched by that will not be "
"included in the result."
msgstr ""
"A lookahead assertion looks at the part of the string following a possible "
"match. The positive lookahead will prevent the string from matching if the "
"text following the possible match does not match the <emphasis>PATTERN</"
"emphasis> of the assertion, but the text matched by that will not be "
"included in the result."

#. Tag: para
#: regular-expressions.docbook:657
#, no-c-format
msgid ""
"The expression <userinput>handy(?=\\w)</userinput> will match at "
"<quote>handy</quote> in <quote>handyman</quote> but not in <quote>That came "
"in handy!</quote>"
msgstr ""
"The expression <userinput>handy(?=\\w)</userinput> will match at "
"<quote>handy</quote> in <quote>handyman</quote> but not in <quote>That came "
"in handy!</quote>"

#. Tag: term
#: regular-expressions.docbook:663
#, no-c-format
msgid "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"
msgstr "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"

#. Tag: para
#: regular-expressions.docbook:665
#, no-c-format
msgid ""
"The negative lookahead prevents a possible match to be acknowledged if the "
"following part of the searched string does match its <emphasis>PATTERN</"
"emphasis>."
msgstr ""
"The negative lookahead prevents a possible match to be acknowledged if the "
"following part of the searched string does match its <emphasis>PATTERN</"
"emphasis>."

#. Tag: para
#: regular-expressions.docbook:668
#, no-c-format
msgid ""
"The expression <userinput>const \\w+\\b(?!\\s*&amp;)</userinput> will match "
"at <quote>const char</quote> in the string <quote>const char* foo</quote> "
"while it can not match <quote>const QString</quote> in <quote>const "
"QString&amp; bar</quote> because the <quote>&amp;</quote> matches the "
"negative lookahead assertion pattern."
msgstr ""
"The expression <userinput>const \\w+\\b(?!\\s*&amp;)</userinput> will match "
"at <quote>const char</quote> in the string <quote>const char* foo</quote> "
"while it can not match <quote>const QString</quote> in <quote>const "
"QString&amp; bar</quote> because the <quote>&amp;</quote> matches the "
"negative lookahead assertion pattern."

#. Tag: term
#: regular-expressions.docbook:678
#, fuzzy, no-c-format
#| msgid "<userinput>(?=PATTERN)</userinput> (Positive lookahead)"
msgid "<userinput>(?&lt;=PATTERN)</userinput> (Positive lookbehind)"
msgstr "<userinput>(?=PATTERN)</userinput> (Positive lookahead)"

#. Tag: para
#: regular-expressions.docbook:679
#, fuzzy, no-c-format
#| msgid ""
#| "A lookahead assertion looks at the part of the string following a "
#| "possible match. The positive lookahead will prevent the string from "
#| "matching if the text following the possible match does not match the "
#| "<emphasis>PATTERN</emphasis> of the assertion, but the text matched by "
#| "that will not be included in the result."
msgid ""
"Lookbehind has the same effect as the lookahead, but works backwards. A "
"lookbehind looks at the part of the string previous a possible match. The "
"positive lookbehind will match a string only if it is preceded by the "
"<emphasis>PATTERN</emphasis> of the assertion, but the text matched by that "
"will not be included in the result."
msgstr ""
"A lookahead assertion looks at the part of the string following a possible "
"match. The positive lookahead will prevent the string from matching if the "
"text following the possible match does not match the <emphasis>PATTERN</"
"emphasis> of the assertion, but the text matched by that will not be "
"included in the result."

#. Tag: para
#: regular-expressions.docbook:683
#, fuzzy, no-c-format
#| msgid ""
#| "The expression <userinput>handy(?=\\w)</userinput> will match at "
#| "<quote>handy</quote> in <quote>handyman</quote> but not in <quote>That "
#| "came in handy!</quote>"
msgid ""
"The expression <userinput>(?&lt;=cup)cake</userinput> will match at "
"<quote>cake</quote> if it is succeeded by <quote>cup</quote> (in "
"<quote>cupcake</quote> but not in <quote>cheesecake</quote> or in "
"<quote>cake</quote> alone)."
msgstr ""
"The expression <userinput>handy(?=\\w)</userinput> will match at "
"<quote>handy</quote> in <quote>handyman</quote> but not in <quote>That came "
"in handy!</quote>"

#. Tag: term
#: regular-expressions.docbook:690
#, fuzzy, no-c-format
#| msgid "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"
msgid "<userinput>(?&lt;!PATTERN)</userinput> (Negative lookbehind)"
msgstr "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"

#. Tag: para
#: regular-expressions.docbook:691
#, fuzzy, no-c-format
#| msgid ""
#| "The negative lookahead prevents a possible match to be acknowledged if "
#| "the following part of the searched string does match its "
#| "<emphasis>PATTERN</emphasis>."
msgid ""
"The negative lookbehind prevents a possible match to be acknowledged if the "
"previous part of the searched string does match its <emphasis>PATTERN</"
"emphasis>."
msgstr ""
"The negative lookahead prevents a possible match to be acknowledged if the "
"following part of the searched string does match its <emphasis>PATTERN</"
"emphasis>."

#. Tag: para
#: regular-expressions.docbook:693
#, fuzzy, no-c-format
#| msgid ""
#| "The expression <userinput>^Peter</userinput> will match at <quote>Peter</"
#| "quote> in the string <quote>Peter, hey!</quote> but not in <quote>Hey, "
#| "Peter!</quote>"
msgid ""
"The expression <userinput>(?&lt;![\\w\\.])[0-9]+</userinput> will match at "
"<quote>123</quote> in the strings <quote>=123</quote> and <quote>-123</"
"quote> while it can not match <quote>123</quote> in <quote>.123</quote> or "
"<quote>word123</quote>."
msgstr ""
"The expression <userinput>^Peter</userinput> will match at <quote>Peter</"
"quote> in the string <quote>Peter, hey!</quote> but not in <quote>Hey, Peter!"
"</quote>"

#. Tag: term
#: regular-expressions.docbook:700
#, fuzzy, no-c-format
#| msgid "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"
msgid "<userinput>(PATTERN)</userinput> (Capturing group)"
msgstr "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"

#. Tag: para
#: regular-expressions.docbook:702
#, no-c-format
msgid ""
"The sub pattern within the parentheses is captured and remembered, so that "
"it can be used in back references. For example, the expression "
"<userinput>(&amp;quot;+)[^&amp;quot;]*\\1</userinput> matches "
"<userinput>&quot;&quot;&quot;&quot;text&quot;&quot;&quot;&quot;</userinput> "
"and <userinput>&quot;text&quot;</userinput>."
msgstr ""

#. Tag: para
#: regular-expressions.docbook:707
#, no-c-format
msgid ""
"See the section <link linkend=\"regex-capturing\">Capturing matching text "
"(back references)</link> for more information."
msgstr ""

#. Tag: term
#: regular-expressions.docbook:713
#, fuzzy, no-c-format
#| msgid "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"
msgid "<userinput>(?:PATTERN)</userinput> (Non-capturing group)"
msgstr "<userinput>(?!PATTERN)</userinput> (Negative lookahead)"

#. Tag: para
#: regular-expressions.docbook:715
#, no-c-format
msgid ""
"The sub pattern within the parentheses is not captured and is not "
"remembered. It is preferable to always use non-capturing groups if the "
"captures will not be used."
msgstr ""

#~ msgid ""
#~ "The POSIX notation of classes, <userinput>[:&lt;class name&gt;:]</"
#~ "userinput> is currently not supported."
#~ msgstr ""
#~ "The POSIX notation of classes, <userinput>[:&lt;class name&gt;:]</"
#~ "userinput> is currently not supported."

#~ msgid ""
#~ "If you want to use a back reference, use a sub pattern to have the "
#~ "desired part of the pattern remembered."
#~ msgstr ""
#~ "If you want to use a back reference, use a sub pattern to have the "
#~ "desired part of the pattern remembered."

#, fuzzy
#~ msgid "{1}"
#~ msgstr "{,1}"

#~ msgid "See also <link linkend=\"backreferences\">Back references</link>."
#~ msgstr "See also <link linkend=\"backreferences\">Back references</link>."

#~ msgid "Back References"
#~ msgstr "Back References"

#~ msgid "Patterns"
#~ msgstr "Patterns"

#~ msgid "Assertions"
#~ msgstr "Assertions"

#~ msgid "Quantifiers"
#~ msgstr "Quantifiers"
